### RxJS 适用的问题：

- 如何控制大量代码的复杂度；
- 如何保持代码可读；
- 如何处理异步操作。

### 函数式编程

#### 什么是函数式编程？

函数式编程要求包括以下几点

- 声明式（Declarative）
- 纯函数（Pure Function）
- 数据不可变性（Immutability）

##### 声明式

| **特性**    | **命令式**     | **声明式**         |
| --------- | ----------- | --------------- |
| **关注点**   | 如何做（步骤）     | 做什么（结果）         |
| **代码复杂度** | 通常更冗长       | 通常更简洁           |
| **控制权**   | 开发者控制细节     | 框架/引擎自动处理细节     |
| **典型场景**  | 算法实现、底层系统开发 | 数据处理、UI 开发、配置管理 |
| **可读性**   | 依赖代码注释      | 更接近自然语言         |
###### **生活中的类比**

- **命令式**：  
    “做一杯咖啡，需要：1. 烧水；2. 磨咖啡豆；3. 将咖啡粉倒入滤纸；4. 缓慢倒入热水…”
    
- **声明式**：  
    “请给我一杯拿铁咖啡。”
###### **优缺点**
- **命令式**：
    - ✅ 灵活，能精准控制细节。
    - ❌ 代码冗长，维护成本高，容易出错（如循环边界错误）。
- **声明式**：
    - ✅ 简洁、可维护性强、符合人类直觉。
    - ❌ 灵活性较低，依赖底层实现（如 SQL 性能依赖数据库优化）。

##### 纯函数

- 相同的输入，永远得到相同的输出
- 无副作用（No Side Effects）  
    纯函数不会修改外部状态，包括：  
    修改全局变量、参数或外部对象  
    执行 I/O 操作（如读写文件、网络请求）  
    触发事件（如 DOM 操作、日志输出）

| **场景**                 | **是否纯函数** | **原因**         |
| ---------------------- | --------- | -------------- |
| `Math.max(1, 2)`       | ✅ 纯       | 固定输入，固定输出，无副作用 |
| `Date.now()`           | ❌ 非纯      | 输出随时间变化        |
| `console.log('Hello')` | ❌ 非纯      | 产生副作用（I/O 操作）  |
| `arr.slice(0, 2)`      | ✅ 纯       | 不修改原数组         |
| `arr.splice(0, 2)`     | ❌ 非纯      | 修改原数组（副作用）     |
##### 数据不可变性

- **不可变数据**：数据被创建后，其值（或结构）在生命周期内永远不变。
- **修改操作**：对数据的任何“修改”会生成一个**新副本**，原始数据保持不变。


### 函数式编程为什么最近才崛起

#### 历史原因

因为当时的硬件制造技术还很不发达，电子元件远没有当今这样的水平，那时候每一个电子元件制造成本高，而且体积大，无法在一小片芯片上放置很多元件，无论是运算元件还是存储元件，都是又慢又贵。

1965年，电子芯片公司Intel的创始人戈登·摩尔根据观察，做了这样的断言：​“当价格不变时，集成电路上可容纳的元器件的数目，约每隔18～24个月便会增加一倍，性能也将提升一倍。​”这也就是著名的“摩尔定律”​，

但是，进入21世纪之后，大家发现“摩尔定律”渐渐不管用了，集成电路上的元器件数目不能增长得这么快，因为，电子部件的密度快要达到物理极限了，一个集成电路上没法聚集更多的器件，虽然工程师们还在进一步提高CPU的性能，但是，普遍认同的观点是，单核的运算能力不可能保持摩尔定律的增长速度。这时候，芯片的发展方向转为多核，软件架构也向分布式方向发展。这种转化很合理，既然一个核一秒钟只能做N次运算，那么我用8个核，一秒就能进行8N次运算；同样，一个CPU中核的数量虽然是有限的，但是可以把计算量分布在不同的计算机上，假如一台计算机一秒钟的运算能力是N，那么1000台计算机，一秒钟的计算能力就是1000N。

#### 语言演进

除了硬件性能和软件开发需求的推动，语言的演进也是推动函数式编程被接受的一大动因。

曾几何时，只有Haskell和LISP这样的纯函数式编程语言才高举这面大旗，但是后来，一些本来属于命令式阵营或者面向对象阵营的编程语言也开始添加函数式的特性，这样，更多的开发者能够接触到函数式这种编程思想。增加了函数式特性的这些语言，当然包括 JavaScript。

### 函数式编程和面向对象编程的比较

两种编程方式都可以让代码更容易理解，不过方式不同。简单说来，**面向对象**的方法把**状态的改变封装起来**，以此达到让代码清晰的目的；而**函数式编程**则是**尽量减少变化的部分**，以此让代码逻辑更加清晰

**面向对象的思想**是**把数据封装在类的实例对象中**，把数据藏起来，**让外部不能直接操作**这些对象，只能通过类提供的实例方法来读取和修改这些数据，这样就限制了对数据的访问方式。对于毫无节制任意修改数据的编程方式，面向对象无疑是巨大的进步，因为通过定义类的方法，可以控制对数据的操作。

但是，面向对象隐藏数据的特点，带来了一个先天的缺陷，就是数据的修改历史完全被隐藏了。有人说，面向对象编程提供了一种持续编写烂代码的方式，它让你通过一系列补丁来拼凑程序 。这话有点过激，但是也道出了面向对象编程的缺点。

当我们在代码中看到一个对象实例的时候，即使知道了对象的当前状态，也没法知道这个对象是如何一步一步走到这个状态的，这种不确定性导致代码可维护性下降。**函数式编程**中，**倾向于数据就是数据**，**函数就是函数**，函数可以处理数据，也是并不像面向对象的类概念一样把数据和函数封在一起，而是让**每个函数都不要去修改原有数据（不可变性）​**，而且通过**产生新的数据**来**作为运算结果（纯函数）。